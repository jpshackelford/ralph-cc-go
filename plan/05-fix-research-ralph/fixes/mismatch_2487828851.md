# Fix: mismatch_2487828851 - Logical AND/OR operators compiled as bitwise

## Summary

Logical operators `&&` and `||` are incorrectly compiled as bitwise `&` and `|` operators, producing wrong results for boolean expressions.

## Test Case

```c
static int16_t g_2 = (-8);

static uint8_t func_1(void) {
    uint8_t l_3 = 0;
    l_3 = (g_2 && g_2);  // Should be 1 (both non-zero)
    // ... rest of function uses l_3
}

int main(void) {
    func_1();
    return (int)(g_2) & 127;  // Expected: 120, Actual: 0
}
```

## Expected vs Actual

- `g_2 = -8` (non-zero)
- `g_2 && g_2` should evaluate to `1` (logical AND of two non-zero values)
- But ralph-cc computes `g_2 & g_2 = -8 & -8 = -8` (bitwise AND)

This cascades through the function, ultimately affecting the return value.

## Root Cause

In `pkg/simplexpr/transform.go`, the `cabsToBinaryOp` function has placeholder code that maps logical operators to bitwise operators:

```go
case cabs.OpAnd:
    // Logical && is not directly in Clight - handled via conditionals
    return clight.Oand // placeholder  <-- BUG: should NOT be a placeholder!
case cabs.OpOr:
    // Logical || is not directly in Clight - handled via conditionals
    return clight.Oor // placeholder   <-- BUG: should NOT be a placeholder!
```

The comment acknowledges that `&&` and `||` need special handling via conditionals, but the code just falls through to use bitwise operators.

## Fix Plan

Add explicit handling for `cabs.OpAnd` and `cabs.OpOr` in `transformBinary()` (around line 354) before the `default` case.

The transformation should convert:
- `a && b` → `a ? (b ? 1 : 0) : 0`  (short-circuit evaluation)
- `a || b` → `a ? 1 : (b ? 1 : 0)`  (short-circuit evaluation)

### Implementation

```go
func (t *Transformer) transformBinary(expr cabs.Binary) TransformResult {
    switch expr.Op {
    // ... existing cases ...

    case cabs.OpAnd:
        // Logical && with short-circuit: a && b => a ? (b ? 1 : 0) : 0
        return t.transformLogicalAnd(expr.Left, expr.Right)

    case cabs.OpOr:
        // Logical || with short-circuit: a || b => a ? 1 : (b ? 1 : 0)
        return t.transformLogicalOr(expr.Left, expr.Right)

    case cabs.OpComma:
        return t.transformComma(expr.Left, expr.Right)

    default:
        // ...
    }
}

func (t *Transformer) transformLogicalAnd(left, right cabs.Expr) TransformResult {
    // Transform: a && b => a ? (b ? 1 : 0) : 0
    // Use Sifthenelse statements to implement short-circuit evaluation
    
    leftResult := t.TransformExpr(left)
    rightResult := t.TransformExpr(right)
    
    // Result type is always int (0 or 1)
    resultType := ctypes.Int()
    tempID := t.newTemp(resultType)
    
    one := clight.Econst_int{Value: 1, Typ: resultType}
    zero := clight.Econst_int{Value: 0, Typ: resultType}
    
    // if (left) { if (right) temp=1 else temp=0 } else { temp=0 }
    var stmts []clight.Stmt
    stmts = append(stmts, leftResult.Stmts...)
    
    innerIf := clight.Sifthenelse{
        Cond:     rightResult.Expr,
        Then:     clight.Sset{TempID: tempID, RHS: one},
        Else:     clight.Sset{TempID: tempID, RHS: zero},
    }
    // Prepend rightResult.Stmts to innerIf
    var innerStmts []clight.Stmt
    innerStmts = append(innerStmts, rightResult.Stmts...)
    innerStmts = append(innerStmts, innerIf)
    
    outerIf := clight.Sifthenelse{
        Cond: leftResult.Expr,
        Then: clight.Ssequence{Stmts: innerStmts},
        Else: clight.Sset{TempID: tempID, RHS: zero},
    }
    stmts = append(stmts, outerIf)
    
    return TransformResult{
        Stmts: stmts,
        Expr:  clight.Etempvar{ID: tempID, Typ: resultType},
    }
}

func (t *Transformer) transformLogicalOr(left, right cabs.Expr) TransformResult {
    // Transform: a || b => a ? 1 : (b ? 1 : 0)
    // Similar structure with inverted logic
    
    leftResult := t.TransformExpr(left)
    rightResult := t.TransformExpr(right)
    
    resultType := ctypes.Int()
    tempID := t.newTemp(resultType)
    
    one := clight.Econst_int{Value: 1, Typ: resultType}
    zero := clight.Econst_int{Value: 0, Typ: resultType}
    
    // if (left) { temp=1 } else { if (right) temp=1 else temp=0 }
    var stmts []clight.Stmt
    stmts = append(stmts, leftResult.Stmts...)
    
    innerIf := clight.Sifthenelse{
        Cond: rightResult.Expr,
        Then: clight.Sset{TempID: tempID, RHS: one},
        Else: clight.Sset{TempID: tempID, RHS: zero},
    }
    var innerStmts []clight.Stmt
    innerStmts = append(innerStmts, rightResult.Stmts...)
    innerStmts = append(innerStmts, innerIf)
    
    outerIf := clight.Sifthenelse{
        Cond: leftResult.Expr,
        Then: clight.Sset{TempID: tempID, RHS: one},
        Else: clight.Ssequence{Stmts: innerStmts},
    }
    stmts = append(stmts, outerIf)
    
    return TransformResult{
        Stmts: stmts,
        Expr:  clight.Etempvar{ID: tempID, Typ: resultType},
    }
}
```

## Files to Modify

1. `pkg/simplexpr/transform.go`:
   - Add `case cabs.OpAnd:` and `case cabs.OpOr:` in `transformBinary()`
   - Add `transformLogicalAnd()` and `transformLogicalOr()` helper functions
   - Can remove the placeholder cases from `cabsToBinaryOp()` or keep for error detection

## Alternative Approaches

1. **Use Clight conditional expressions**: If Clight supports conditional expressions (`Econd`), could use that instead of if/then/else statements
2. **Use comparison to zero**: Transform `a && b` to `(a != 0) & (b != 0)` - simpler but doesn't have short-circuit semantics (evaluates both sides)

The short-circuit version is preferred for correctness (C semantics) and efficiency (skip right side if left is false/true for &&/||).

## Test Verification

After fix, the test case should:
1. Evaluate `g_2 && g_2` as `1` (since -8 is non-zero)
2. Return exit code `120` (same as clang reference)

Create a minimal test:
```c
int main(void) {
    int x = -8;
    int result = (x && x);  // Should be 1
    return result;
}
```
